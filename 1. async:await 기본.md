## Async-Await
```swift

//Swift 5.5까지 비동기 코드 작성에는 많은 단점이 있었다 아래 예를 한번 살펴보자.

func fetch(completion: @escaping (Data) -> Void) {
    URLSession.shared.dataTask(with: URL(string: "www.naver.com")!) { data, response, error in
        if let error = error {
            return
        }
        completion(data!)
    }
    .resume()
}

func fetchData() {
    fetch { [weak self] data in
        self?.viewModel.data = data
    }
}

/*
 이는 네트워크 요청을 수행하고 그 결과를 ViewModel 속성에 할당하는 짧은 코드지만 몇가지 문제가 있다.
 1. 컴파일러는 completion을 호출한 횟수를 알수 없다. 따라서 수명을 최적화 할수 없다.
 2. Weak Self 약한캡쳐를 시켜 메모리를 관리처리 해야한다.
 3. 컴파일러는 사용자가 오류를 처리했는지 알수없다. 실제로 클로져에서 오류처리를 잊어버리거나 완료를 호출하지않으면 메서드가 자동정지된다.
*/

/*
 Swift의 최신 동시성 모델인 async await은 컴파일러와 긴밀하게 작동한다.
 위의 예시에서 동일한 목표를 달성하기 위해 다음 세가지 도구를 제공한다.
 1. asnyc: 메서드나 함수가 비동기적임을 나타낸다. 이를 사용하면 비동기 메서드가 결과를 반환할때 까지 실행을일시 중단할수 있다.
 2. await: 코드가 대기하는동안 실행을 일시 중지할수 있음을 나타낸다.
 3. task: 비동기작업의 단위다. 작업이 완료될때까지 기다리거나 취소할수 있다.

 최신 동시성 모델 구문을 사용했을때 얻을수 있는 결과는다음과 같다.
 */

func fetch() async throws -> Data {
    do {
        let (data, _) = try await URLSession.shared.data(from: URL(string: "www.naver.com")!)
        return data
    } catch let error {
        throw error
    }
}

func fetchData() {
    Task {
        viewModel.data = fetch()
    }
}

/*
 위의 코드는 이전 예제와 거의 동일한 줄수가 있지만. 컴파일러와 런타임 모두에 의도가 더 명확하다 구체적으로.
 1. fetch()는 실행을 일시중지하고 재개할 수 있는 비동기함수다. async로 표시한다.
 2. fetch()는 데이터를 반환하거나 오류를 발생시킨다. 이는 컴파일 타임에 확인된다.
 3. Task는 비동기 컨텍스트에서 지정된 클로저를 실행하므로 컴파일러는 해당 클로저에서 안전하지 않은 코드를 작성하지 못하도록 보호할수 있다.
 4. await 키워드를 사용하여 비동기 함수를 호출할때마다 런타임에 코드를 일시 중단하거나 취소할수 있는 기회를 제공한다. 이를통해 현재 작업 대기열의 우선순위를 지속적으로 변경가능하다.
 */

/*
 최신 동시성 모델에서는 코드가 대기할때마다 일시중단될수 있다.
 이는 무슨뜻일까?
 CPU 코어 및 메모리와 같은 공유 리소스를 최적화하기 위해 Swift는 분할된다.
 코드를 부분 작업 또는 부분 작업이라는 논리 단위로 변환한다. 이는 비동기적으로 실행하려는 코드 부분을 나타낸다.
 */

func myFunction() async throws {
    let log = try await severLog()
    for try await line in log.lines {
        if try await line.isConnected {
            await sendLogLine(line)
        }
    }
}

/*
 Swift 런타임은 비동기 실행을 위해 이러한 각부분을 개별적으로 예약한다. 각 부분 작업이 완료되면 시스템은 코드를 계속 이어갈지 아니면
 다른 작업을 실행할지 결정한다.

 그렇기때문에 작업은 시스템제량에 따라 다른 쓰레드에서 실행될수 있다는 점을 기억하는것이 중요하다.
 대기 후 앱 상태에 대해 가정하면 안된다. 두줄의 코드가 차례로 나타나더라도 일정 시간의 간격을 두고 실행된다.
 요약하자면 async await은 많은 효과를 주는 간단한 구문이다. 이를통해 컴파일러는 안전하고 견고한 코드를 작성하도록 안내하는 동시에
 런타임은 공유리소스를 적절하게 사용하도록 최적하한다.
 
 결국 최신 동시성 모델의 장점은 다음과 같다.
 
 1. 동기코드같은 코드작성으로 코드의 가독성 향상
 2. 동키코드에서처럼 에러처리가 보다 자연스럽게 가능
 3. 중첩 클로져를 피할수 있음.
 4. 클로져 약한 캡쳐 불 필요
 5. 컴파일러 수준에서 await 지점에서 작업을 일시중지하고 다시시작하는 방법을 관리 및 최적화
 6. 런타임에서 적절한 컨텍스트 전환으로 스레드 풀을 효과적으로 활용 가능 
 */
 
 
```
## Task 수명 제어

```
/*
최신 동시성의 새로운 필수 기능중 하나는 비동기 코드의 수명을 관리하는 시스템 기능이다.
이전 멀티스레드 API의 가장 큰 단점은 비동기 코드조각이 실행되기 시작하면 
해당작업을 취소하기가 어려웠다는것이다.

이에대한 좋은예는 서버에서 컨텐츠를 가져오는 서비스이다. 이 서비스를 두번 호출하면
시스템에는 불필요한 첫번째 호출에서 사용한 리소스를 회수하는 메커니즘이 없기때문에 불푤이한 낭비가 되어버린다.

새로운 동시성 모델은 코드가 부분적으로 나뉘어 실행 지점마다 체크인하도록한다.
이렇게 하면 시스템이 실행을 일시 중단하거나 아예 취소할수 있는 기회를 제공한다.
새로운 비동기 모델 덕분에 특정 작업을 취소하면 런타임이 비동기 계층을 따라 내려가면서 모든 하위 작업도 취소할수 있다.

하지만 중간에 실행을 멈추지않고 길고 지루한 계산을 수행하는 작업이 있다면 어떻게 해야할까?
Swift는 현재 작업이 취소되었는지 감지할수 있는 API를 제공해 작업이 취소되었으면 수동으로 실행을 포기할수 있따.

마지막으로 실행지점은 오류가 계층을 따라 올라가서 오류를 잡아 처리하는 코드에 도달할수 있는 탈출경로도 제공한다. 새로운 비동기모델은 동기함수와 유사한 오류처리를 제공하고
현대적이고 잘 알려진 오류 던지기 함수를 사용한다. 또한 오류가 발생하면 신속하게 메모리를 해제하도록 최적화 되어있다.



*/
```
