# Learn-Async-Await
```swift

//Swift 5.5까지 비동기 코드 작성에는 많은 단점이 있었다 아래 예를 한번 살펴보자.

func fetch(completion: @escaping (Data) -> Void) {
    URLSession.shared.dataTask(with: URL(string: "www.naver.com")!) { data, response, error in
        if let error = error {
            return
        }
        completion(data!)
    }
    .resume()
}

func fetchData() {
    fetch { [weak self] data in
        self?.viewModel.data = data
    }
}

/*
 이는 네트워크 요청을 수행하고 그 결과를 ViewModel 속성에 할당하는 짧은 코드지만 몇가지 문제가 있다.
 1. 컴파일러는 completion을 호출한 횟수를 알수 없다. 따라서 수명을 최적화 할수 없다.
 2. Weak Self 약한캡쳐를 시켜 메모리를 관리처리 해야한다.
 3. 컴파일러는 사용자가 오류를 처리했는지 알수없다. 실제로 클로져에서 오류처리를 잊어버리거나 완료를 호출하지않으면 메서드가 자동정지된다.
*/

/*
 Swift의 최신 동시성 모델인 async await은 컴파일러와 긴밀하게 작동한다.
 위의 예시에서 동일한 목표를 달성하기 위해 다음 세가지 도구를 제공한다.
 1. asnyc: 메서드나 함수가 비동기적임을 나타낸다. 이를 사용하면 비동기 메서드가 결과를 반환할때 까지 실행을일시 중단할수 있다.
 2. await: 코드가 대기하는동안 실행을 일시 중지할수 있음을 나타낸다.
 3. task: 비동기작업의 단위다. 작업이 완료될때까지 기다리거나 취소할수 있다.

 최신 동시성 모델 구문을 사용했을때 얻을수 있는 결과는다음과 같다.
 */

func fetch() async throws -> Data {
    do {
        let (data, _) = try await URLSession.shared.data(from: URL(string: "www.naver.com")!)
        return data
    } catch let error {
        throw error
    }
}

func fetchData() {
    Task {
        viewModel.data = fetch()
    }
}

/*
 위의 코드는 이전 예제와 거의 동일한 줄수가 있지만. 컴파일러와 런타임 모두에 의도가 더 명확하다 구체적으로.
 1. fetch()는 실행을 일시중지하고 재개할 수 있는 비동기함수다. async로 표시한다.
 2. fetch()는 데이터를 반환하거나 오류를 발생시킨다. 이는 컴파일 타임에 확인된다.
 3. Task는 비동기 컨텍스트에서 지정된 클로저를 실행하므로 컴파일러는 해당 클로저에서 안전하지 않은 코드를 작성하지 못하도록 보호할수 있다.
 4. await 키워드를 사용하여 비동기 함수를 호출할때마다 런타임에 코드를 일시 중단하거나 취소할수 있는 기회를 제공한다. 이를통해 현재 작업 대기열의 우선순위를 지속적으로 변경가능하다.
 */

/*
 최신 동시성 모델에서는 코드가 대기할때마다 일시중단될수 있다.
 이는 무슨뜻일까?
 CPU 코어 및 메모리와 같은 공유 리소스를 최적화하기 위해 Swift는 분할된다.
 코드를 부분 작업 또는 부분 작업이라는 논리 단위로 변환한다. 이는 비동기적으로 실행하려는 코드 부분을 나타낸다.
 */

func myFunction() async throws {
    let log = try await severLog()
    for try await line in log.lines {
        if try await line.isConnected {
            await sendLogLine(line)
        }
    }
}

/*
 Swift 런타임은 비동기 실행을 위해 이러한 각부분을 개별적으로 예약한다. 각 부분 작업이 완료되면 시스템은 코드를 계속 이어갈지 아니면
 다른 작업을 실행할지 결정한다.

 그렇기때문에 작업은 시스템제량에 따라 다른 쓰레드에서 실행될수 있다는 점을 기억하는것이 중요하다.
 대기 후 앱 상태에 대해 가정하면 안된다. 두줄의 코드가 차례로 나타나더라도 일정 시간의 간격을 두고 실행된다.
 요약하자면 async await은 많은 효과를 주는 간단한 구문이다. 이를통해 컴파일러는 안전하고 견고한 코드를 작성하도록 안내하는 동시에
 런타이믄 공유리소스를 적절하게 사용하도록 최적하한다.
 */
```
